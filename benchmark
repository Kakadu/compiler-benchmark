#!/usr/bin/env python3

import argparse
import subprocess
import os.path
import shutil
from string import Template as Tm
from timeit import default_timer as timer


DEFAULT_PROGRAM_NAME = 'linear'


def main():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument("--function-count", type=int,
                        default=100,
                        help="Number of functions generated and called")

    parser.add_argument("--function-call-depth", type=int,
                        default=8,
                        help="Function call depth")

    parser.add_argument("--function-arity", type=int,
                        default=2,
                        help="Function arity")

    parser.add_argument("--run-count", type=int,
                        default=1,
                        help="Number of runs for each compilation")

    args = parser.parse_args()

    C_FLAGS = ['-fsyntax-only', '-Wall', '-Wextra']
    C_CLANG_FLAGS = C_FLAGS + ['-fno-color-diagnostics', '-fno-caret-diagnostics', '-fno-diagnostics-show-option']

    LANGUAGES = ['C', 'C++', 'Java', 'D', 'Rust', 'Zig', 'Go', 'V', 'Julia']

    gpaths = generate_code(languages=LANGUAGES, args=args)

    compilers = {}              # compilers by language
    spans = {}                  # time spans by compiler path

    # D
    benchmark_D(compilers=compilers,
                spans=spans,
                gpaths=gpaths,
                args=args,
                generate_object_file=False)

    # D
    benchmark_D(compilers=compilers,
                spans=spans,
                gpaths=gpaths,
                args=args,
                generate_object_file=True)

    # Clang
    print('Clang:')
    CLANG_VERSIONS = range(5, 13)
    for clang_version in CLANG_VERSIONS:
        language = 'C'
        clang_exec = shutil.which('clang-' + str(clang_version))
        if clang_exec is not None:
            version_run = subprocess.run([clang_exec, '--version'], stdout=subprocess.PIPE)
            version = version_run.stdout.decode('utf-8').split()[2]
            spans['Clang'] = compile_file(path=gpaths['C'],
                                          args=[clang_exec] + C_CLANG_FLAGS,
                                          run_count=args.run_count,
                                          operation_message='Check',
                                          compiler_version=version)
            spans[clang_exec] = spans['Clang']

        language = 'C++'
        clangxx_ = shutil.which('clang++-' + str(clang_version))
        if clangxx_ is not None:
            version_run = subprocess.run([clangxx_, '--version'], stdout=subprocess.PIPE)
            version = version_run.stdout.decode('utf-8').split()[2]
            spans['Clang++'] = compile_file(path=gpaths['C++'],
                                            args=[clangxx_] + C_CLANG_FLAGS,
                                            run_count=args.run_count,
                                            operation_message='Check',
                                            compiler_version=version)
            print_speedup(spans, from_lang='D', to_lang='Clang')
            print_speedup(spans, from_lang='D', to_lang='Clang++')
    print()

    # C GCC
    print('GCC:')
    GCC_VERSIONS = range(5, 13)
    for gcc_version in GCC_VERSIONS:
        language = 'C'
        gcc_exec = shutil.which('gcc-' + str(gcc_version))
        if gcc_exec is not None:
            version_run = subprocess.run([gcc_exec, '--version'], stdout=subprocess.PIPE)
            version = version_run.stdout.decode('utf-8').split()[2]
            spans[gcc_exec] = compile_file(path=gpaths['C'],
                                           args=[gcc_exec] + C_FLAGS,
                                           run_count=args.run_count,
                                           operation_message='Check',
                                           compiler_version=version)
            spans['gcc-' + str(gcc_version)] = spans[gcc_exec]

        language = 'C++'
        gxx_exec = shutil.which('g++-' + str(gcc_version))
        if gxx_exec is not None:
            version_run = subprocess.run([gxx_exec, '--version'], stdout=subprocess.PIPE)
            version = version_run.stdout.decode('utf-8').split()[2]
            spans[gxx_exec] = compile_file(path=gpaths['C++'],
                                           args=[gxx_exec] + C_FLAGS,
                                           run_count=args.run_count,
                                           operation_message='Check',
                                           compiler_version=version)
            spans['g++-' + str(gcc_version)] = spans[gxx_exec]
            print_speedup(spans, from_lang='D', to_lang='gcc-9')
            print_speedup(spans, from_lang='D', to_lang='g++-9')
    print()

    # Go
    language = 'Go'
    gccgo_exec = shutil.which('gccgo')
    if gccgo_exec is not None:
        print(language + ':')
        if language not in compilers:
            compilers[language] = gccgo_exec
            version_run = subprocess.run([gccgo_exec, '--version'], stdout=subprocess.PIPE)
            version = version_run.stdout.decode('utf-8').split()[2]
            spans[language] = compile_file(path=gpaths[language],
                                           args=[gccgo_exec, '-fsyntax-only', '-S'],
                                           run_count=args.run_count,
                                           operation_message='Check',
                                           compiler_version=version)
            print_speedup(spans, from_lang='D', to_lang='Go')
            print()

    # V (vlang.io)
    language = 'V'
    v_exec = shutil.which('/home/per/ware/vlang/v')  # shutil.which('v')
    if v_exec is not None:
        print(language + ':')
        if language not in compilers:
            compilers[language] = v_exec
            version_run = subprocess.run([v_exec, '--version'], stdout=subprocess.PIPE)
            version = version_run.stdout.decode('utf-8').split()[1]
            vlang_backends = ['c', 'js', 'x64', 'v2', 'experimental']
            spans[language] = compile_file(path=gpaths[language],
                                           args=[v_exec, '-backend', 'x64'],
                                           run_count=args.run_count,
                                           operation_message='Compilation',
                                           compiler_version=version)
            print_speedup(spans, from_lang='D', to_lang='V')
            print()

    # Zig
    language = 'Zig'
    print(language + ':')
    zig_exec = shutil.which('zig')
    if zig_exec is not None:
        if language not in compilers:
            compilers[language] = zig_exec
            version_run = subprocess.run([zig_exec, 'version'], stdout=subprocess.PIPE)
            version = version_run.stdout.decode('utf-8').split()[0]
            spans[language] = compile_file(path=gpaths['Zig'],
                                           args=[zig_exec, 'build-obj', '-fno-emit-bin'],
                                           run_count=args.run_count,  # no syntax flag currently so compile to object file instead
                                           operation_message='Compilation',
                                           compiler_version=version)
            print_speedup(spans, from_lang='D', to_lang='Zig')
            print()

    # Rust
    language = 'Rust'
    rustc_exec = shutil.which('rustc')
    if rustc_exec is not None:
        print(language + ':')
        if language not in compilers:
            compilers[language] = rustc_exec
            # See: https://stackoverflow.com/questions/53250631/does-rust-have-a-way-to-perform-syntax-and-semantic-analysis-without-generating/53250674#53250674
            # See: https://stackoverflow.com/questions/51485765/run-rustc-to-check-a-program-without-generating-any-files
            # Alternatives:
            # - `rustc --emit=metadata -Z no-codegen`
            # - Not yet in stable: `rustc -Z no-codegen`
            # - 'rustc', '--crate-type', 'lib', '--emit=mir', '-o', '/dev/null', '--test'
        version_run = subprocess.run([rustc_exec, '--version'], stdout=subprocess.PIPE)
        version = version_run.stdout.decode('utf-8').split()[1]
        spans[language] = compile_file(path=gpaths['Rust'],
                                       args=[rustc_exec, '-Z', 'no-codegen'],
                                       run_count=args.run_count,
                                       operation_message='Check',
                                       compiler_version=version)
        print_speedup(spans, from_lang='D', to_lang='Rust')
        print()

    # Java
    language = 'Java'
    java_exec = shutil.which('javac')
    if java_exec is not None:
        print(language + ':')
        if language not in compilers:
            compilers[language] = java_exec
            spans[language] = compile_file(path=gpaths[language],
                                           args=[java_exec, '-Xdiags:verbose'],
                                           run_count=args.run_count,
                                           operation_message='Compilation')
            print_speedup(spans, from_lang='D', to_lang='Java')
            print()

    # Julia
    language = 'Julia'
    julia_exec = shutil.which('julia')
    if julia_exec is not None:
        print(language + ':')
        if language not in compilers:
            compilers[language] = julia_exec
        spans[language] = compile_file(path=gpaths['Julia'],
                                       args=[julia_exec],
                                       run_count=args.run_count,
                                       operation_message='Compilation')
        print_speedup(spans, from_lang='D', to_lang='Julia')
        print()

    # print('Speedups' + ':')
    # pprint(spans)


def generate_code(languages, args):
    print('Code-generation:')
    gpaths = {}
    for language in languages:
        gpaths[language] = generate_test_program(language=language,
                                                 args=args)
    print()
    return gpaths


def benchmark_GCC(compilers, spans, gpaths, args):
    pass


def benchmark_Clang(compilers, spans, gpaths, args):
    pass


def benchmark_D(compilers, spans, gpaths, args,
                generate_object_file):

    operation_message = 'Compilation' if generate_object_file else "Check"
    language = 'D' + ('-compilation' if generate_object_file else "")
    d_flags = ['-dip25', '-dip1008', '-dip1000']  # use DIPs

    print(language + ':')

    if language not in spans:
        spans[language] = []

    exec_args = '-c' if generate_object_file else '-o-'

    # DMD
    dmd_exec = shutil.which('dmd')
    if dmd_exec is not None:
        version_run = subprocess.run([dmd_exec, '--version'], stdout=subprocess.PIPE)
        version = version_run.stdout.decode('utf-8').split()[3]
        if language not in compilers:
            compilers[language] = dmd_exec
        spans[language].append(compile_file(path=gpaths['D'],
                                            args=[dmd_exec, exec_args] + d_flags,
                                            run_count=args.run_count,
                                            operation_message=operation_message,
                                            compiler_version=version))

    # LDC
    ldc_exec = shutil.which('ldmd2')
    if ldc_exec is not None:
        version_run = subprocess.run([ldc_exec, '--version'], stdout=subprocess.PIPE)
        version = version_run.stdout.decode('utf-8').split()[6][1:-2]
        if language not in compilers:
            compilers[language] = ldc_exec
        spans[language].append(compile_file(path=gpaths['D'],
                                            args=[ldc_exec, exec_args] + d_flags,
                                            run_count=args.run_count,
                                            operation_message=operation_message,
                                            compiler_version=version))

    spans[language] = min(spans[language])

    print()


def compile_file(path, args, run_count=1,
                 operation_message='Check',
                 compiler_version=None):

    compiler = shutil.which(args[0])
    if compiler is None:
        print('Could not find compiler:', args[0])
        return None

    spans = []
    for _ in range(0, run_count):
        start = timer()
        # print(args + [path])
        with subprocess.Popen(args + [path],
                              stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE) as proc:
            results = proc.communicate()
            end = timer()
            span = end - start
            spans.append(span)
            if results[0]:
                print('stdout:', results[0])
            if results[1]:
                print('stderr:', results[1])

    span_min = min(spans)

    show_file = False
    compiler_version_str = " version " + str(compiler_version) if compiler_version is not None else ""
    if show_file:
        print('- {} of {} took {:1.3f} seconds (using "{}"{})'.format(operation_message, path, span_min, args[0],
                                                                      compiler_version_str))
    else:
        print('- {} took {:1.3f} seconds (using "{}"{})'.format(operation_message, span_min, args[0],
                                                                compiler_version_str))

    return span


def long_types_of_lang(lang):
    if lang in ['c', 'c++', 'java']:
        return ['long']
    elif lang in ['d']:
        return ['long']
    elif lang in ['rust', 'zig', 'v']:
        return ['i64']
    elif lang == 'go':
        return ['int64']
    elif lang == 'julia':
        return ['Int64']
    else:
        return None


def language_file_extension(lang):
    if lang == 'rust':
        return 'rs'
    elif lang == 'julia':
        return 'jl'
    else:
        return lang


def generate_test_program(language,
                          args,
                          root_path='generated',
                          templated_function=False):
    program_name = DEFAULT_PROGRAM_NAME

    lang = language.lower()
    types = long_types_of_lang(lang)
    ext = language_file_extension(lang)
    dir_path = os.path.join(root_path, lang)
    os.makedirs(dir_path, exist_ok=True)
    path = os.path.join(dir_path, program_name + '.' + ext)

    start = timer()
    with open(path, 'w') as f:
        generate_test_language_specific_prefix(lang, program_name, f)
        generate_linear_test_function_definition_set(lang, types, args.function_count, f, templated_function=False)
        generate_test_main_header(lang, types, f)
        for typ in types:
            generate_linear_test_function_variable(lang, typ, f)
            for function_index in range(0, args.function_count):
                generate_test_function_call(lang, function_index, typ, f)
        generate_test_language_specific_postfix(lang, types, f)
    end = timer()
    span = (end - start)  # time span
    print("- Generating {} took {:1.3f} seconds ({})".format(path, span, language))
    # print("Generated {} source file: {}".format(language.upper(), path))

    return path  # "-betterC"


def generate_test_function_call(lang, function_index, typ, f):
    if lang in ["java"]:
        f.write('    ')
    f.write(Tm('    ${T}_sum += add_${T}_${N}(${N})').substitute(T=typ, N=str(function_index)))
    if lang not in ["v"]:
        f.write(';')
    f.write('\n')


def generate_test_language_specific_prefix(lang, program_name, f):
    # package definition
    if lang == "go":
        f.write('package ' + program_name + ';\n\n')
    # if lang == "v":
    #     f.write('import os\n\n')

    # special modules
    if lang == "rust":
        f.write('use std::process::exit;\n')

    # special class wrapping
    if lang == "java":
        f.write('class HelloWorld {\n')


def generate_test_language_specific_postfix(lang, types, f):
    if lang == "rust":
        f.write(Tm('    exit((${T}_sum % 4294967296) as i32);\n}\n').substitute(T=types[0]))
    elif lang == "v":
        f.write(Tm('    exit(int(${T}_sum))\n}\n').substitute(T=types[0]))
    elif lang == "java":
        f.write(Tm('        System.exit(${T}_sum == 42 ? 1 : 0);\n    }\n').substitute(T=types[0]))
    elif lang == "zig":
        f.write(Tm('\n}\n').substitute(T=types[0]))
    elif lang == "julia":
        f.write(Tm('''    return ${T}_sum;
end

main()
''').substitute(T=types[0]))
    elif lang == "d":
        f.write(Tm('''    return cast(int)${T}_sum;
}
''').substitute(T=types[0]))
    else:
        f.write(Tm('''    return ${T}_sum;
}
''').substitute(T=types[0]))

    if lang == "java":
        f.write('}\n')            # one extra closing brace for class


def generate_linear_test_function_definition_set(lang, types, function_count, f, templated_function=False):
    for typ in types:
        for function_index in range(0, function_count):
            generate_test_function_definition(lang, typ, function_index, f, templated_function=False)
        f.write('\n')


def generate_test_function_definition(lang, typ, function_index, f, templated_function=False):
    if lang in ["c"]:
        f.write(Tm('${T} add_${T}_${N}(${T} x) { return x + ${N}; }\n').substitute(T=typ, N=str(function_index)))
    elif lang in ["java"]:
        f.write(Tm('    static ${T} add_${T}_${N}(${T} x) { return x + ${N}; }\n').substitute(T=typ, N=str(function_index)))
    elif lang in ["c++"]:
        f.write(Tm('${X}${T} add_${T}_${N}(${T} x) { return x + ${N}; }\n')
                .substitute(T=typ,
                            N=str(function_index),
                            X='template<typename T=int> ' if templated_function else ''))
        # template<typename T1, typename T2 = int> class A;
    if lang in ["d"]:
        f.write(Tm('${T} add_${T}_${N}${X}(${T} x) pure { return x + ${N}; }\n')
                .substitute(T=typ,
                            N=str(function_index),
                            X='(alias T=void)' if templated_function else ''))
    elif lang == "rust":
        f.write(Tm('fn add_${T}_${N}(x: ${T}) -> ${T} { x + ${N} }\n').substitute(T=typ, N=str(function_index)))
    elif lang == "zig":
        f.write(Tm('fn add_${T}_${N}(x: ${T}) ${T} { return x + ${N}; }\n').substitute(T=typ, N=str(function_index)))
    elif lang == "go":
        f.write(Tm('func add_${T}_${N}(x ${T}) ${T} { return x + ${N} }\n').substitute(T=typ, N=str(function_index)))
    elif lang == "v":
        f.write(Tm('fn add_${T}_${N}(x ${T}) ${T} { return x + ${N} }\n').substitute(T=typ, N=str(function_index)))
    elif lang == "julia":
        f.write(Tm('function add_${T}_${N}(x::${T})::${T}\n    return x + ${N}\nend;\n').substitute(T=typ, N=str(function_index)))


def generate_test_main_header(lang, types, f):
    if lang in ["c", "c++"]:
        f.write('int main(__attribute__((unused)) int argc, __attribute__((unused)) char* argv[]) {\n')
    elif lang == "java":
        f.write('    public static void main(String args[]) {\n')
    elif lang == "d":
        f.write('int main(string[] args) {\n')
    elif lang == "rust":
        f.write(Tm('fn main() {\n').substitute(T=types[0]))
    elif lang == "zig":
        f.write(Tm('pub fn main() void {\n').substitute(T=types[0]))
    elif lang == "go":
        f.write(Tm('func main() ${T} {\n').substitute(T=types[0]))
    elif lang == "v":
        f.write(Tm('fn main() {\n').substitute(T=types[0]))
    elif lang == "julia":
        f.write(Tm('function main()::${T}\n').substitute(T=types[0]))
    else:
        assert False


def generate_linear_test_function_variable(lang, typ, f):
    if lang in ["c", "c++", "d"]:
        f.write(Tm('    ${T} ${T}_sum = 0;\n').substitute(T=typ))
    elif lang in ["java"]:
        f.write(Tm('        ${T} ${T}_sum = 0;\n').substitute(T=typ))
    elif lang == "rust":
        f.write(Tm('    let mut ${T}_sum : ${T} = 0;\n').substitute(T=typ))
    elif lang == "zig":
        f.write(Tm('    var ${T}_sum: ${T} = 0;\n').substitute(T=typ))
    elif lang == "go":
        f.write(Tm('    var ${T}_sum ${T} = 0;\n').substitute(T=typ))
    elif lang == "v":
        f.write(Tm('    mut ${T}_sum := ${T}(0)\n').substitute(T=typ))
    elif lang == "julia":
        f.write(Tm('    ${T}_sum::${T} = 0;\n').substitute(T=typ))
    else:
        assert False


def generate_test_program_2(function_count, language, root_path='generated'):
    program_name = "sample2"

    lang = language.lower()
    types = long_types_of_lang(lang)
    ext = language_file_extension(lang)
    dir_path = os.path.join(root_path, lang)
    os.makedirs(dir_path, exist_ok=True)
    path = os.path.join(dir_path, program_name + "." + ext)

    start = timer()
    with open(path, 'w') as f:

        # package definition
        if lang == "go":
            f.write('''package ''' + program_name + ''';

''')

        # standard io module
        if lang in ["c"]:
            f.write('''#include <stdio.h>
''')
        if lang in ["c++"]:
            f.write('''#include <iostream>
''')
        if lang == "d":
            f.write('''import std.stdio;
''')
        if lang == "rust":
            f.write('''use std::io;
''')
        if lang == "go":
            f.write('''import "fmt";

''')
        if lang == "v":
            f.write('''import os
''')

        # special modules
        if lang == "rust":
            f.write('''use std::process::exit;
''')

        for typ in types:
            for function_index in range(0, function_count):
                if lang in ["c", "c++"]:
                    f.write(Tm('''${T} add_${T}_${N}(${T} x) { return x + ${N}; }
''').substitute(T=typ, N=str(function_index)))
                if lang in ["d"]:
                    f.write(Tm('''${T} add_${T}_${N}(${T} x) pure { return x + ${N}; }
''').substitute(T=typ, N=str(function_index)))
                elif lang == "rust":
                    f.write(Tm('''fn add_${T}_${N}(x: ${T}) -> ${T} { x + ${N} }
''').substitute(T=typ, N=str(function_index)))
                elif lang == "zig":
                    f.write(Tm('''fn add_${T}_${N}(x: ${T}) ${T} { return x + ${N}; }
''').substitute(T=typ, N=str(function_index)))
                elif lang == "go":
                    f.write(Tm('''func add_${T}_${N}(x ${T}) ${T} { return x + ${N} }
''').substitute(T=typ, N=str(function_index)))
                elif lang == "v":
                    f.write(Tm('''fn add_${T}_${N}(x ${T}) ${T} { return x + ${N} }
''').substitute(T=typ, N=str(function_index)))
                elif lang == "julia":
                    f.write(Tm('''function add_${T}_${N}(x::${T})::${T}
    return x + ${N}
end;
''').substitute(T=typ, N=str(function_index)))
                    f.write('\n')

        # MAIN HEADER
        if lang in ["c", "c++"]:
            f.write('''int main(__attribute__((unused)) int argc, __attribute__((unused)) char* argv[])
{
''')
        elif lang == "d":
            f.write('''int main(string[] args)
{
''')
        elif lang == "rust":
            f.write(Tm('''fn main() {
''').substitute(T=types[0]))
        elif lang == "zig":
            f.write(Tm('''pub fn main() void {
''').substitute(T=types[0]))
        elif lang == "go":
            f.write(Tm('''func main() ${T} {
''').substitute(T=types[0]))
        elif lang == "v":
            f.write(Tm('''fn main() ${T} {
''').substitute(T=types[0]))
        elif lang == "julia":
            f.write(Tm('''function main()::${T}
''').substitute(T=types[0]))
        else:
            assert False

        # CALCULATE
        for typ in types:
            if lang in ["c", "c++", "d"]:
                f.write(Tm('''    ${T} ${T}_sum = 0;
''').substitute(T=typ))
            elif lang == "rust":
                f.write(Tm('''    let mut ${T}_sum : ${T} = 0;
''').substitute(T=typ))
            elif lang == "zig":
                f.write(Tm('''    var ${T}_sum: ${T} = 0;
''').substitute(T=typ))
            elif lang == "go":
                f.write(Tm('''    var ${T}_sum ${T} = 0;
''').substitute(T=typ))
            elif lang == "v":
                f.write(Tm('''    var ${T}_sum ${T} = 0;
''').substitute(T=typ))
            elif lang == "julia":
                f.write(Tm('''    ${T}_sum::${T} = 0;
''').substitute(T=typ))
            else:
                assert False

            for function_index in range(0, function_count):
                f.write(Tm('''    ${T}_sum += add_${T}_${N}(${N});
''').substitute(T=typ, N=str(function_index)))

        if lang == "rust":
            f.write(Tm('''    exit(${T}_sum);
}
''').substitute(T=types[0]))
        elif lang == "zig":
            f.write(Tm('''
}
''').substitute(T=types[0]))
        elif lang == "julia":
            f.write(Tm('''    return ${T}_sum;
end

main()
''').substitute(T=types[0]))
        elif lang == "d":
            f.write(Tm('''    return cast(int)${T}_sum;
}
''').substitute(T=types[0]))
        else:
            f.write(Tm('''    return ${T}_sum;
}
''').substitute(T=types[0]))

    end = timer()
    span = (end - start)  # time span
    print("- Generating {} took {:1.3f} seconds ({})".format(path, span, language))

    # print("Generated {} source file: {}".format(language.upper(), path))

    return path  # "-betterC"


def print_speedup(spans, from_lang, to_lang):
    try:
        print("- Speedup of {} over {}: {:.2f}".format(from_lang,
                                                       to_lang,
                                                       spans[to_lang] / spans[from_lang]))
    except KeyError:
        pass


if __name__ == '__main__':
    main()
