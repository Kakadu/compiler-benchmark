#!/usr/bin/env python3

import argparse
import subprocess
import os.path
import os
import shutil
from pprint import pprint

from string import Template as Tm
from timeit import default_timer as timer

LANGUAGES = ['C', 'C++', 'Java', 'D', 'Rust', 'Zig', 'Go', 'V', 'Julia']
TEMPLATED_LANGUAGES = ['C++', 'Java', 'D', 'Rust', 'Zig', 'V', 'Julia']
DEFAULT_PROGRAM_NAME = 'linear'
C_FLAGS = ['-Wall', '-Wextra']
TABLE_TITLES = ['Language', 'Templated', 'Oper', 'Exec Path', 'Exec Version', "Time [s]", "Time vs D"]


def srcIdOf(lang, templated):
    if lang in TEMPLATED_LANGUAGES:
        return lang + ('-Templated' if templated else '-Untemplated')
    else:
        return lang


def opIdOf(lang, templated, op, exec_path=None):
    if lang == 'D' and exec_path is None:
        exec_path = 'dmd'
    return srcIdOf(lang, templated) + '-' + op + '-' + str(exec_path)


def row_list(spans, lang, op, exec_path, exec_version, span, templated):
    if lang.startswith('D'):
        speedup_D = 'N/A'
    else:
        speedup_D = factor_str(span / spans[opIdOf('D', templated, op)])
    exec_path = os.path.join("~", exec_path.lstrip(os.getenv('HOME')))
    return [lang,
            'Yes' if templated else 'No',
            op,
            '`' + exec_path + '`',
            exec_version,
            ms_str(span),
            speedup_D]


def ms_str(span):
    return "{:.3f}".format(span)


def factor_str(factor):
    return "{:.1f}".format(factor)


def md_header(text, nr):        # Markdown header
    return '#' * nr + ' ' + text


def md_table(header, rows):
    result = ''

    result += '| '
    for col in header:
        result += str(col) + ' | '
    result += '\n'

    result += '| '
    for ix, col in enumerate(range(len(header))):
        if ix == 2:
            result += '---' + ' | '
        else:
            result += ':---:' + ' | '
    result += '\n'

    for row in rows:
        result += '| '
        for col in row:
            result += str(col) + ' | '
        result += '\n'
    return result


def main():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument("--function-count", type=int,
                        default=100,
                        help="Number of functions generated and called")

    parser.add_argument("--function-depth", type=int,
                        default=100,
                        help="Function call depth")

    parser.add_argument("--run-count", type=int,
                        default=1,
                        help="Number of runs for each compilation")

    args = parser.parse_args()

    gpaths = generate_code(languages=LANGUAGES, args=args)

    execs = {}                   # execs by language
    spans = {}                  # time spans by compiler path

    results = []

    # D
    results += benchmark_D(execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=False, templated=False)
    results += benchmark_D(execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=False, templated=True)
    results += benchmark_D(execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=True, templated=False)
    results += benchmark_D(execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=True, templated=True)

    # C
    results += benchmark_GCC(lang='C', execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=False, templated=False)
    results += benchmark_Clang(lang='C', execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=False, templated=False)
    results += benchmark_GCC(lang='C', execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=True, templated=False)
    results += benchmark_Clang(lang='C', execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=True, templated=False)

    # C++
    results += benchmark_GCC(lang='C++', execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=False, templated=False)
    results += benchmark_Clang(lang='C++', execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=False, templated=False)
    results += benchmark_GCC(lang='C++', execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=False, templated=True)
    results += benchmark_Clang(lang='C++', execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=False, templated=True)
    results += benchmark_GCC(lang='C++', execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=True, templated=False)
    results += benchmark_Clang(lang='C++', execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=True, templated=False)
    results += benchmark_GCC(lang='C++', execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=True, templated=True)
    results += benchmark_Clang(lang='C++', execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=True, templated=True)

    # Go
    results += benchmark_Go(execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=False, templated=False)

    # V
    results += benchmark_V(execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=False, templated=False)

    # Zig
    results += benchmark_Zig(execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=False, templated=False)
    results += benchmark_Zig(execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=False, templated=True)

    # Rust
    results += benchmark_Rust(execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=False, templated=False)
    results += benchmark_Rust(execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=True, templated=False)

    # Java
    results += benchmark_Java(execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=True, templated=False)

    # Julia
    results += benchmark_Julia(execs=execs, spans=spans, gpaths=gpaths, args=args, gen_obj=True, templated=False)

    # print('Speedups' + ':')
    # pprint(spans)

    print(md_table(TABLE_TITLES, results))


def generate_code(languages, args):
    print(md_header('Code-generation:', 1))
    gpaths = {}
    for lang in languages:
        templated = False
        gpaths[srcIdOf(lang, templated)] = generate_test_program(lang=lang,
                                                                 args=args,
                                                                 templated=templated)
        if lang in TEMPLATED_LANGUAGES:
            templated = True
            gpaths[srcIdOf(lang, templated)] = generate_test_program(lang=lang,
                                                                     args=args,
                                                                     templated=templated)
    print()
    return gpaths


def benchmark_GCC(lang, execs, spans, gpaths, args, gen_obj, templated):
    results = list()
    op = 'Build' if gen_obj else "Check"
    print(md_header('GCC:', 2))
    GCC_VERSIONS = range(5, 15)
    exec_args = [] if gen_obj else ['-fsyntax-only']
    for gcc_version in GCC_VERSIONS:
        if lang == 'C':
            gcc_exec = shutil.which('gcc-' + str(gcc_version))
        elif lang == 'C++':
            gcc_exec = shutil.which('g++-' + str(gcc_version))
        else:
            assert(False)
        if gcc_exec is not None:
            version_run = subprocess.run([gcc_exec, '--version'], stdout=subprocess.PIPE)
            version = version_run.stdout.decode('utf-8').split()[2].split('-')[0]
            span_min = compile_file(path=gpaths[srcIdOf(lang, templated)],
                                    args=[gcc_exec] + C_FLAGS + exec_args,
                                    run_count=args.run_count,
                                    op=op,
                                    compiler_version=version)
            opId = opIdOf(lang, templated, op, gcc_exec)
            spans[opId] = span_min
            results.append(row_list(spans, lang, op, gcc_exec, version, span_min, templated))
            print_speedup(spans, from_opId=opIdOf('D', templated, op), to_opId=opId)
    print()
    return results


def benchmark_Clang(lang, execs, spans, gpaths, args, gen_obj, templated):
    results = list()
    op = 'Build' if gen_obj else "Check"
    C_CLANG_FLAGS = C_FLAGS + ['-fno-color-diagnostics', '-fno-caret-diagnostics', '-fno-diagnostics-show-option']
    print(md_header('Clang:', 2))
    CLANG_VERSIONS = range(5, 15)
    exec_args = [] if gen_obj else ['-fsyntax-only']
    for clang_version in CLANG_VERSIONS:
        if lang == 'C':
            clang_exec = shutil.which('clang-' + str(clang_version))
        elif lang == 'C++':
            clang_exec = shutil.which('clang++-' + str(clang_version))
        else:
            assert(False)
        if clang_exec is not None:
            version_run = subprocess.run([clang_exec, '--version'], stdout=subprocess.PIPE)
            version = version_run.stdout.decode('utf-8').split()[2].split('-')[0]
            span_min = compile_file(path=gpaths[srcIdOf(lang, templated)],
                                    args=[clang_exec] + C_CLANG_FLAGS + exec_args,
                                    run_count=args.run_count,
                                    op=op,
                                    compiler_version=version)
            results.append(row_list(spans, lang, op, clang_exec, version, span_min, templated))
            opId = opIdOf(lang, templated, op, clang_exec)
            spans[opId] = span_min
            print_speedup(spans, from_opId=opIdOf('D', templated, op), to_opId=opId)
    print()
    return results


def benchmark_D(execs, spans, gpaths, args, gen_obj, templated):

    results = list()

    op = 'Build' if gen_obj else "Check"
    lang = 'D'
    d_flags = ['-dip25', '-dip1008', '-dip1000']  # use DIPs

    exec_args = '-c' if gen_obj else '-o-'

    # DMD
    dmd_exec = shutil.which('dmd')
    if dmd_exec is not None:
        opId = opIdOf(lang, templated, op, 'dmd')
        print(md_header(opId + ':', 2))

        version_run = subprocess.run([dmd_exec, '--version'], stdout=subprocess.PIPE)
        version = version_run.stdout.decode('utf-8').split()[3]
        if opId not in execs:
            execs[opId] = dmd_exec
        span_min = compile_file(path=gpaths[srcIdOf(lang, templated)],
                                args=[dmd_exec, exec_args] + d_flags,
                                run_count=args.run_count,
                                op=op,
                                compiler_version=version)
        results.append(row_list(spans, lang, op, dmd_exec, version, span_min, templated))
        spans[opId] = span_min

    # LDC
    ldc_exec = shutil.which('ldmd2')
    if ldc_exec is not None:
        opId = opIdOf(lang, templated, op, 'ldmd2')
        print(md_header(opId + ':', 2))

        version_run = subprocess.run([ldc_exec, '--version'], stdout=subprocess.PIPE)
        version = version_run.stdout.decode('utf-8').split()[6][1:-2]
        if opId not in execs:
            execs[opId] = ldc_exec
        span_min = compile_file(path=gpaths[srcIdOf(lang, templated)],
                                args=[ldc_exec, exec_args] + d_flags,
                                run_count=args.run_count,
                                op=op,
                                compiler_version=version)
        results.append(row_list(spans, lang, op, ldc_exec, version, span_min, templated))
        spans[opId] = span_min

    print()

    return results


def benchmark_Go(execs, spans, gpaths, args, gen_obj, templated):
    op = 'Build' if gen_obj else "Check"
    results = list()
    lang = 'Go'
    gccgo_exec = shutil.which('gccgo')
    if gccgo_exec is not None:
        print(md_header(lang + ':', 2))
        if lang not in execs:
            execs[lang] = gccgo_exec
            version_run = subprocess.run([gccgo_exec, '--version'], stdout=subprocess.PIPE)
            version = version_run.stdout.decode('utf-8').split()[2].split('-')[0]
            span_min = compile_file(path=gpaths[srcIdOf(lang, templated)],
                                    args=[gccgo_exec, '-fsyntax-only', '-S'],
                                    run_count=args.run_count,
                                    op=op,
                                    compiler_version=version)
            opId = opIdOf(lang, templated, op, gccgo_exec)
            spans[opId] = span_min
            results.append(row_list(spans, lang, op, gccgo_exec, version, span_min, templated))
            print_speedup(spans, from_opId=opIdOf('D', templated, op), to_opId=opId)
            print()
    return results


def benchmark_V(execs, spans, gpaths, args, gen_obj, templated):
    op = 'Build'
    results = list()
    # V (vlang.io)
    lang = 'V'
    v_exec = shutil.which('/home/per/ware/vlang/v')  # shutil.which('v')
    if v_exec is not None:
        print(md_header(lang + ':', 2))
        if lang not in execs:
            execs[lang] = v_exec
            version_run = subprocess.run([v_exec, '--version'], stdout=subprocess.PIPE)
            version = version_run.stdout.decode('utf-8').split()[1]
            vlang_backends = ['c', 'js', 'x64', 'v2', 'experimental']
            span_min = compile_file(path=gpaths[srcIdOf(lang, templated)],
                                    args=[v_exec, '-backend', vlang_backends[2]],
                                    run_count=args.run_count,
                                    op=op,
                                    compiler_version=version)
            opId = opIdOf(lang, templated, op, v_exec)
            spans[opId] = span_min
            results.append(row_list(spans, lang, op, v_exec, version, span_min, templated))
            print_speedup(spans, from_opId=opIdOf('D', templated, op), to_opId=opId)
            print()
    return results


def benchmark_Zig(execs, spans, gpaths, args, gen_obj, templated):
    op = 'Build'
    results = list()
    lang = 'Zig'
    print(md_header(lang + ':', 2))
    zig_exec = shutil.which('zig')
    if zig_exec is not None:
        if lang not in execs:
            execs[lang] = zig_exec
            version_run = subprocess.run([zig_exec, 'version'], stdout=subprocess.PIPE)
            version = version_run.stdout.decode('utf-8').split()[0]
            span_min = compile_file(path=gpaths[srcIdOf(lang, templated)],
                                    args=[zig_exec, 'build-obj', '-fno-emit-bin'],
                                    run_count=args.run_count,  # no syntax flag currently so compile to object file instead
                                    op=op,
                                    compiler_version=version)
            opId = opIdOf(lang, templated, op, zig_exec)
            spans[opId] = span_min
            results.append(row_list(spans, lang, op, zig_exec, version, span_min, templated))
            print_speedup(spans, from_opId=opIdOf('D', templated, op), to_opId=opId)
            print()
    return results


def benchmark_Rust(execs, spans, gpaths, args, gen_obj, templated):
    results = list()

    lang = 'Rust'
    op = 'Build' if gen_obj else "Check"
    rustc_exec = shutil.which('rustc')
    if rustc_exec is not None:
        opId = opIdOf(lang, templated, op, rustc_exec)
        print(md_header(opId + ':', 2))
        if opId not in execs:
            execs[opId] = rustc_exec
            # See: https://stackoverflow.com/questions/53250631/does-rust-have-a-way-to-perform-syntax-and-semantic-analysis-without-generating/53250674#53250674
            # See: https://stackoverflow.com/questions/51485765/run-rustc-to-check-a-program-without-generating-any-files
            # Alternatives:
            # - `rustc --emit=metadata -Z no-codegen`
            # - Not yet in stable: `rustc -Z no-codegen`
            # - 'rustc', '--crate-type', 'lib', '--emit=mir', '-o', '/dev/null', '--test'
        version_run = subprocess.run([rustc_exec, '--version'], stdout=subprocess.PIPE)
        version = version_run.stdout.decode('utf-8').split()[1]
        span_min = compile_file(path=gpaths[srcIdOf(lang, templated)],
                                args=[rustc_exec] if gen_obj else [rustc_exec, '-Z', 'no-codegen'],
                                run_count=args.run_count,
                                op=op,
                                compiler_version=version)
        spans[opId] = span_min
        results.append(row_list(spans, lang, op, rustc_exec, version, span_min, templated))
        print_speedup(spans,
                      from_opId=opIdOf('D', templated, op),
                      to_opId=opId)
        print()
    return results


def benchmark_Java(execs, spans, gpaths, args, gen_obj, templated):
    op = 'Build'
    results = list()
    lang = 'Java'
    java_exec = shutil.which('javac')
    if java_exec is not None:
        opId = opIdOf(lang, templated, op, java_exec)
        print(md_header(lang + ':', 2))
        if lang not in execs:
            execs[opId] = java_exec
            span_min = compile_file(path=gpaths[srcIdOf(lang, templated)],
                                    args=[java_exec, '-Xdiags:verbose'],
                                    run_count=args.run_count,
                                    op=op)
            spans[opId] = span_min
            results.append(row_list(spans, lang, op, java_exec, 'unknown', span_min, templated))
            print_speedup(spans,
                          from_opId=opIdOf('D', templated, op),
                          to_opId=opId)
            print()
    return results


def benchmark_Julia(execs, spans, gpaths, args, gen_obj, templated):
    op = 'Build'
    results = list()
    lang = 'Julia'
    julia_exec = shutil.which('julia')
    if julia_exec is not None:
        print(md_header(lang + ':', 2))
        if lang not in execs:
            execs[lang] = julia_exec
        span_min = compile_file(path=gpaths[srcIdOf(lang, templated)],
                                args=[julia_exec],
                                run_count=args.run_count,
                                op=op)
        opId = opIdOf(lang, templated, op, julia_exec)
        spans[opId] = span_min
        results.append(row_list(spans, lang, op, julia_exec, 'unknown', span_min, templated))
        print_speedup(spans,
                      from_opId=opIdOf('D', templated, op),
                      to_opId=opId)
        print()
    return results


def compile_file(path, args, run_count=1,
                 op='Check',
                 compiler_version=None):

    compiler = shutil.which(args[0])
    if compiler is None:
        print('Could not find compiler:', args[0])
        return None

    spans = []
    for _ in range(0, run_count):
        start = timer()
        # print(args + [path])
        with subprocess.Popen(args + [path],
                              stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE) as proc:
            results = proc.communicate()
            end = timer()
            span = end - start
            spans.append(span)
            if results[0]:
                print('stdout:', results[0])
            if results[1]:
                print('stderr:', results[1])

    span_min = min(spans)

    show_file = False
    compiler_version_str = " version " + str(compiler_version) if compiler_version is not None else ""
    if show_file:
        print('- {} of {} took {:1.3f} seconds (using "{}"{})'.format(op, path, span_min, args[0],
                                                                      compiler_version_str))
    else:
        print('- {} took {:1.3f} seconds (using "{}"{})'.format(op, span_min, args[0],
                                                                compiler_version_str))

    return span_min


def long_types_of_lang(lang):
    if lang in ['c', 'c++', 'java']:
        return ['long']
    elif lang in ['d']:
        return ['long']
    elif lang in ['rust', 'zig', 'v']:
        return ['i64']
    elif lang == 'go':
        return ['int64']
    elif lang == 'julia':
        return ['Int64']
    else:
        return None


def language_file_extension(lang):
    if lang == 'rust':
        return 'rs'
    elif lang == 'julia':
        return 'jl'
    else:
        return lang


def generate_test_program(lang,
                          args,
                          templated,
                          root_path='generated'):
    program_name = DEFAULT_PROGRAM_NAME

    llang = lang.lower()        # lowered language
    types = long_types_of_lang(llang)
    ext = language_file_extension(llang)
    dir_path = os.path.join(root_path, llang)
    os.makedirs(dir_path, exist_ok=True)
    path = os.path.join(dir_path, program_name + ('_t' if templated else '') + '.' + ext)

    start = timer()
    with open(path, 'w') as f:
        generate_test_language_specific_prefix(llang, program_name, f)

        generate_linear_test_function_definition_set(llang, types, args, f,
                                                     templated=templated)
        generate_test_main_header(llang, types, f)
        for typ in types:
            generate_linear_test_function_variable(llang, typ, f)
            for findex in range(0, args.function_count):
                generate_test_function_call(llang, findex, typ, f, templated=templated)

        generate_test_language_specific_postfix(llang, types, f)
    end = timer()
    span = (end - start)  # time span
    print("- Generating {} took {:1.3f} seconds ({})".format(path, span, lang))
    # print("Generated {} source file: {}".format(llang.upper(), path))

    return path  # "-betterC"


def generate_test_function_call(lang, findex, typ, f, templated):
    if lang in ["java"]:
        f.write('    ')

    if lang == "zig" and templated:  # Zig needs explicit template type
        f.write(Tm('    ${T}_sum += add_${T}_n${N}(i64, ${N})').substitute(T=typ, N=str(findex)))
    else:
        f.write(Tm('    ${T}_sum += add_${T}_n${N}(${N})').substitute(T=typ, N=str(findex)))

    if lang not in ["v"]:
        f.write(';')
    f.write('\n')


def generate_test_language_specific_prefix(lang, program_name, f):
    # package definition
    if lang == "go":
        f.write('package ' + program_name + ';\n\n')
    # if lang == "v":
    #     f.write('import os\n\n')

    # special modules
    if lang == "rust":
        f.write('use std::process::exit;\n')

    # special class wrapping
    if lang == "java":
        f.write('class HelloWorld {\n')


def generate_test_language_specific_postfix(lang, types, f):
    if lang == "rust":
        f.write(Tm('    exit((${T}_sum % 4294967296) as i32);\n}\n').substitute(T=types[0]))
    elif lang == "v":
        f.write(Tm('    exit(int(${T}_sum))\n}\n').substitute(T=types[0]))
    elif lang == "java":
        f.write(Tm('        System.exit(${T}_sum == 42 ? 1 : 0);\n    }\n').substitute(T=types[0]))
    elif lang == "zig":
        f.write(Tm('\n}\n').substitute(T=types[0]))
    elif lang == "julia":
        f.write(Tm('''    return ${T}_sum;
end

main()
''').substitute(T=types[0]))
    elif lang == "d":
        f.write(Tm('''    return cast(int)${T}_sum;
}
''').substitute(T=types[0]))
    else:
        f.write(Tm('''    return ${T}_sum;
}
''').substitute(T=types[0]))

    if lang == "java":
        f.write('}\n')            # one extra closing brace for class


def generate_linear_test_function_definition_set(lang, types, args, f,
                                                 templated):
    for typ in types:
        for findex in range(0, args.function_count):
            for fheight in range(0, args.function_depth):
                generate_test_function_definition(args, lang, typ, findex, fheight, f,
                                                  templated=templated)
            f.write('\n')
        f.write('\n')


def function_name(typ, findex, fheight):
    if fheight is not None:
        return Tm('add_${T}_n${N}_h${H}').substitute(T=typ,
                                                     N=str(findex),
                                                     H=str(fheight))
    else:
        return Tm('add_${T}_n${N}').substitute(T=typ,
                                               N=str(findex))


def generate_test_function_definition(args, lang, typ, findex, fheight, f,
                                      templated):
    if fheight == 0:
        expr = 'x + ' + str(findex)
    else:
        expr = 'x + ' + function_name(typ, findex, fheight - 1) + '(x) + ' + str(findex)

    if fheight == args.function_depth - 1:
        fname = function_name(typ, findex, fheight=None)
    else:
        fname = function_name(typ, findex, fheight)

    if lang in ["c"]:
        f.write(Tm('${T} ${F}(${T} x) { return ${X}; }\n').substitute(T=typ, F=str(fname), N=str(findex), X=expr))
    elif lang in ["java"]:
        f.write(Tm('    static ${T} ${F}(${T} x) { return ${X}; }\n').substitute(T=typ, F=str(fname), N=str(findex), H=str(fheight), X=expr))
    elif lang in ["c++"]:
        f.write(Tm('${M}${T} ${F}(${T} x) { return ${X}; }\n')
                .substitute(T=typ, F=str(fname), N=str(findex), H=str(fheight),
                            M='template<typename T=int> ' if templated else '',
                            X=expr))
        # template<typename T1, typename T2 = int> class A;
    if lang in ["d"]:
        f.write(Tm('${T} ${F}${M}(${T} x) @safe pure nothrow @nogc { return ${X}; }\n')
                .substitute(T=typ, F=str(fname), N=str(findex), H=str(fheight), M='(alias T=void)' if templated else '', X=expr))
    elif lang == "rust":
        f.write(Tm('fn ${F}(x: ${T}) -> ${T} { ${X} }\n').substitute(T=typ, F=str(fname), N=str(findex), H=str(fheight), X=expr))
    elif lang == "zig":
        if templated:
            f.write(Tm('fn ${F}(comptime T: type, x: T) T { return ${X}; }\n').substitute(T=typ, F=str(fname), N=str(findex), H=str(fheight), X=expr))
        else:
            f.write(Tm('fn ${F}(x: ${T}) ${T} { return ${X}; }\n').substitute(T=typ, F=str(fname), N=str(findex), H=str(fheight), X=expr))
    elif lang == "go":
        f.write(Tm('func ${F}(x ${T}) ${T} { return ${X} }\n').substitute(T=typ, F=str(fname), N=str(findex), H=str(fheight), X=expr))
    elif lang == "v":
        f.write(Tm('fn ${F}(x ${T}) ${T} { return ${X} }\n').substitute(T=typ, F=str(fname), N=str(findex), H=str(fheight), X=expr))
    elif lang == "julia":
        f.write(Tm('function ${F}(x::${T})::${T}\n    return ${X}\nend;\n').substitute(T=typ, F=str(fname), N=str(findex), H=str(fheight), X=expr))


def generate_test_main_header(lang, types, f):
    if lang in ["c", "c++"]:
        f.write('int main(__attribute__((unused)) int argc, __attribute__((unused)) char* argv[]) {\n')
    elif lang == "java":
        f.write('    public static void main(String args[]) {\n')
    elif lang == "d":
        f.write('int main(string[] args) {\n')
    elif lang == "rust":
        f.write(Tm('fn main() {\n').substitute(T=types[0]))
    elif lang == "zig":
        f.write(Tm('pub fn main() void {\n').substitute(T=types[0]))
    elif lang == "go":
        f.write(Tm('func main() ${T} {\n').substitute(T=types[0]))
    elif lang == "v":
        f.write(Tm('fn main() {\n').substitute(T=types[0]))
    elif lang == "julia":
        f.write(Tm('function main()::${T}\n').substitute(T=types[0]))
    else:
        assert False


def generate_linear_test_function_variable(lang, typ, f):
    if lang in ["c", "c++", "d"]:
        f.write(Tm('    ${T} ${T}_sum = 0;\n').substitute(T=typ))
    elif lang in ["java"]:
        f.write(Tm('        ${T} ${T}_sum = 0;\n').substitute(T=typ))
    elif lang == "rust":
        f.write(Tm('    let mut ${T}_sum : ${T} = 0;\n').substitute(T=typ))
    elif lang == "zig":
        f.write(Tm('    var ${T}_sum: ${T} = 0;\n').substitute(T=typ))
    elif lang == "go":
        f.write(Tm('    var ${T}_sum ${T} = 0;\n').substitute(T=typ))
    elif lang == "v":
        f.write(Tm('    mut ${T}_sum := ${T}(0)\n').substitute(T=typ))
    elif lang == "julia":
        f.write(Tm('    ${T}_sum::${T} = 0;\n').substitute(T=typ))
    else:
        assert False


def generate_test_program_2(function_count, lang, root_path='generated'):
    program_name = "sample2"

    lang = lang.lower()
    types = long_types_of_lang(lang)
    ext = language_file_extension(lang)
    dir_path = os.path.join(root_path, lang)
    os.makedirs(dir_path, exist_ok=True)
    path = os.path.join(dir_path, program_name + "." + ext)

    start = timer()
    with open(path, 'w') as f:

        # package definition
        if lang == "go":
            f.write('''package ''' + program_name + ''';

''')

        # standard io module
        if lang in ["c"]:
            f.write('''#include <stdio.h>
''')
        if lang in ["c++"]:
            f.write('''#include <iostream>
''')
        if lang == "d":
            f.write('''import std.stdio;
''')
        if lang == "rust":
            f.write('''use std::io;
''')
        if lang == "go":
            f.write('''import "fmt";

''')
        if lang == "v":
            f.write('''import os
''')

        # special modules
        if lang == "rust":
            f.write('''use std::process::exit;
''')

        for typ in types:
            for findex in range(0, function_count):
                if lang in ["c", "c++"]:
                    f.write(Tm('''${T} add_${T}_n${N}(${T} x) { return x + ${N}; }
''').substitute(T=typ, N=str(findex)))
                if lang in ["d"]:
                    f.write(Tm('''${T} add_${T}_n${N}(${T} x) pure { return x + ${N}; }
''').substitute(T=typ, N=str(findex)))
                elif lang == "rust":
                    f.write(Tm('''fn add_${T}_n${N}(x: ${T}) -> ${T} { x + ${N} }
''').substitute(T=typ, N=str(findex)))
                elif lang == "zig":
                    f.write(Tm('''fn add_${T}_n${N}(x: ${T}) ${T} { return x + ${N}; }
''').substitute(T=typ, N=str(findex)))
                elif lang == "go":
                    f.write(Tm('''func add_${T}_n${N}(x ${T}) ${T} { return x + ${N} }
''').substitute(T=typ, N=str(findex)))
                elif lang == "v":
                    f.write(Tm('''fn add_${T}_n${N}(x ${T}) ${T} { return x + ${N} }
''').substitute(T=typ, N=str(findex)))
                elif lang == "julia":
                    f.write(Tm('''function add_${T}_n${N}(x::${T})::${T}
    return x + ${N}
end;
''').substitute(T=typ, N=str(findex)))
                    f.write('\n')

        # MAIN HEADER
        if lang in ["c", "c++"]:
            f.write('''int main(__attribute__((unused)) int argc, __attribute__((unused)) char* argv[])
{
''')
        elif lang == "d":
            f.write('''int main(string[] args)
{
''')
        elif lang == "rust":
            f.write(Tm('''fn main() {
''').substitute(T=types[0]))
        elif lang == "zig":
            f.write(Tm('''pub fn main() void {
''').substitute(T=types[0]))
        elif lang == "go":
            f.write(Tm('''func main() ${T} {
''').substitute(T=types[0]))
        elif lang == "v":
            f.write(Tm('''fn main() ${T} {
''').substitute(T=types[0]))
        elif lang == "julia":
            f.write(Tm('''function main()::${T}
''').substitute(T=types[0]))
        else:
            assert False

        # CALCULATE
        for typ in types:
            if lang in ["c", "c++", "d"]:
                f.write(Tm('''    ${T} ${T}_sum = 0;
''').substitute(T=typ))
            elif lang == "rust":
                f.write(Tm('''    let mut ${T}_sum : ${T} = 0;
''').substitute(T=typ))
            elif lang == "zig":
                f.write(Tm('''    var ${T}_sum: ${T} = 0;
''').substitute(T=typ))
            elif lang == "go":
                f.write(Tm('''    var ${T}_sum ${T} = 0;
''').substitute(T=typ))
            elif lang == "v":
                f.write(Tm('''    var ${T}_sum ${T} = 0;
''').substitute(T=typ))
            elif lang == "julia":
                f.write(Tm('''    ${T}_sum::${T} = 0;
''').substitute(T=typ))
            else:
                assert False

            for findex in range(0, function_count):
                f.write(Tm('''    ${T}_sum += add_${T}_n${N}(${N});
''').substitute(T=typ, N=str(findex)))

        if lang == "rust":
            f.write(Tm('''    exit(${T}_sum);
}
''').substitute(T=types[0]))
        elif lang == "zig":
            f.write(Tm('''
}
''').substitute(T=types[0]))
        elif lang == "julia":
            f.write(Tm('''    return ${T}_sum;
end

main()
''').substitute(T=types[0]))
        elif lang == "d":
            f.write(Tm('''    return cast(int)${T}_sum;
}
''').substitute(T=types[0]))
        else:
            f.write(Tm('''    return ${T}_sum;
}
''').substitute(T=types[0]))

    end = timer()
    span = (end - start)  # time span
    print("- Generating {} took {:1.3f} seconds ({})".format(path, span, lang))

    # print("Generated {} source file: {}".format(lang.upper(), path))

    return path  # "-betterC"


def print_speedup(spans, from_opId, to_opId):
    print("- Speedup of {} over {}: {:.2f}".format(from_opId,
                                                   to_opId,
                                                   spans[to_opId] / spans[from_opId]))


if __name__ == '__main__':
    main()
