#!/usr/bin/env python3

import argparse
import subprocess
import os.path
import shutil
from string import Template as Tm
from timeit import default_timer as timer


def main():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument("--function-count", type=int,
                        default=10000,
                        help="Number of functions generated and called")

    parser.add_argument("--run-count", type=int,
                        default=1,
                        help="Number of runs for each compilation")

    args = parser.parse_args()

    C_FLAGS = ['-fsyntax-only', '-Wall', '-Wextra']
    C_CLANG_FLAGS = C_FLAGS + ['-fno-color-diagnostics', '-fno-caret-diagnostics', '-fno-diagnostics-show-option']

    CLANG_VERSIONS = [7, 8, 9, 10]
    GCC_VERSIONS = [4, 5, 6, 7, 8, 9, 10]

    languages = ['C', 'C++', 'Java', 'D', 'Rust', 'Zig', 'Go', 'V', 'Julia']

    gpaths = {}                 # generated paths
    spans = {}                  # time spans
    compilers = {}                  # compilers

    print('Code-generation:')
    for language in languages:
        gpaths[language] = generate_test_program_1(function_count=args.function_count,
                                                   language=language)
    print()

    # D
    benchmark_D(compilers=compilers, spans=spans, gpaths=gpaths, args=args)

    # Clang
    print('Clang:')
    for clang_version in CLANG_VERSIONS:
        language = 'C'
        clang_ = shutil.which('clang-' + str(clang_version))
        if clang_ is not None:
            spans['Clang'] = compile_file(path=gpaths['C'],
                                          args=[clang_] + C_CLANG_FLAGS,
                                          run_count=args.run_count)
            spans[clang_] = spans['Clang']

        language = 'C++'
        clangxx_ = shutil.which('clang++-' + str(clang_version))
        if clangxx_ is not None:
            spans['Clang++'] = compile_file(path=gpaths['C++'],
                                            args=[clangxx_] + C_CLANG_FLAGS,
                                            run_count=args.run_count)
            print_speedup(spans, from_lang='D', to_lang='Clang')
            print_speedup(spans, from_lang='D', to_lang='Clang++')
    print()

    # C GCC
    print('GCC:')
    for gcc_version in GCC_VERSIONS:
        language = 'C'
        gcc_ = shutil.which('gcc-' + str(gcc_version))
        if gcc_ is not None:
            spans[gcc_] = compile_file(path=gpaths['C'],
                                       args=[gcc_] + C_FLAGS,
                                       run_count=args.run_count)
            spans['gcc-' + str(gcc_version)] = spans[gcc_]

        language = 'C++'
        gxx_ = shutil.which('g++-' + str(gcc_version))
        if gxx_ is not None:
            spans[gxx_] = compile_file(path=gpaths['C++'],
                                       args=[gxx_] + C_FLAGS,
                                       run_count=args.run_count)
            spans['g++-' + str(gcc_version)] = spans[gxx_]
            print_speedup(spans, from_lang='D', to_lang='gcc-9')
            print_speedup(spans, from_lang='D', to_lang='g++-9')
    print()

    # Go
    language = 'Go'
    gccgo_ = shutil.which('gccgo')
    if gccgo_ is not None:
        print(language + ':')
        if language not in compilers:
            compilers[language] = gccgo_
        spans[language] = compile_file(path=gpaths[language],
                                       args=[gccgo_, '-fsyntax-only', '-S'],
                                       run_count=args.run_count)
        print_speedup(spans, from_lang='D', to_lang='Go')
        print()

    # Java
    language = 'Java'
    java_ = shutil.which('javac')
    if java_ is not None:
        print(language + ':')
        if language not in compilers:
            compilers[language] = java_
            spans[language] = compile_file(path=gpaths[language],
                                           args=[java_, '-Xdiags:verbose'],
                                           run_count=args.run_count)
            print_speedup(spans, from_lang='D', to_lang='Java')
            print()

    # Rust
    language = 'Rust'
    rustc_ = shutil.which('rustc')
    if rustc_ is not None:
        print(language + ':')
        if language not in compilers:
            compilers[language] = rustc_
            # See: https://stackoverflow.com/questions/53250631/does-rust-have-a-way-to-perform-syntax-and-semantic-analysis-without-generating/53250674#53250674
            # See: https://stackoverflow.com/questions/51485765/run-rustc-to-check-a-program-without-generating-any-files
            # Alternatives:
            # - `rustc --emit=metadata -Z no-codegen`
            # - Not yet in stable: `rustc -Z no-codegen`
            # - 'rustc', '--crate-type', 'lib', '--emit=mir', '-o', '/dev/null', '--test'
        spans[language] = compile_file(path=gpaths['Rust'],
                                       args=[rustc_, '-Z', 'no-codegen'],
                                       run_count=args.run_count)
        print_speedup(spans, from_lang='D', to_lang='Rust')
        print()

    # V (vlang.io)
    language = 'V'
    v_ = os.path.expanduser('~/Work/v/v')
    if v_ is not None:
        print(language + ':')
        if language not in compilers:
            compilers[language] = v_
        spans[language] = compile_file(path=gpaths[language],
                                       args=[v_, 'build'],
                                       run_count=args.run_count)
        print_speedup(spans, from_lang='D', to_lang='V')
        print()

    # Zig
    language = 'Zig'
    print(language + ':')
    zig_ = shutil.which('zig')
    if zig_ is not None:
        if language not in compilers:
            compilers[language] = zig_
        spans[language] = compile_file(path=gpaths['Zig'],
                                       args=[zig_, 'build-obj', '-fno-emit-bin'],
                                       run_count=args.run_count)  # no syntax flag currently so compile to object file instead
        print_speedup(spans, from_lang='D', to_lang='Zig')
        print()

    # Julia
    language = 'Julia'
    julia_ = shutil.which('julia')
    if julia_ is not None:
        print(language + ':')
        if language not in compilers:
            compilers[language] = julia_
        spans[language] = compile_file(path=gpaths['Julia'],
                                       args=[julia_],
                                       run_count=args.run_count)
        print_speedup(spans, from_lang='D', to_lang='Julia')
        print()

    # print('Speedups' + ':')
    # pprint(spans)


def benchmark_D(compilers, spans, gpaths, args):

    language = 'D'
    d_flags = ['-dip25', '-dip1008', '-dip1000']  # use DIPs

    print(language + ':')

    if language not in spans:
        spans[language] = []

    # DMD
    dmd_ = shutil.which('dmd')
    if dmd_ is not None:
        if language not in compilers:
            compilers[language] = dmd_
        spans[language].append(compile_file(path=gpaths['D'],
                                            args=[dmd_, '-o-'] + d_flags,
                                            run_count=args.run_count))

    # LDC
    ldc_ = shutil.which('ldmd2')
    if ldc_ is not None:
        if language not in compilers:
            compilers[language] = ldc_
        spans[language].append(compile_file(path=gpaths['D'],
                                            args=[ldc_, '-o-'] + d_flags,
                                            run_count=args.run_count))

    spans[language] = min(spans[language])

    print()


def compile_file(path, args, run_count=1):

    compiler = shutil.which(args[0])
    if compiler is None:
        print('Could not find compiler:', args[0])
        return None

    spans = []
    for _ in range(0, run_count):
        start = timer()
        with subprocess.Popen(args + [path],
                              stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE) as proc:
            results = proc.communicate()
            end = timer()
            span = end - start
            spans.append(span)
            if results[0]:
                print('stdout:', results[0])
            if results[1]:
                print('stderr:', results[1])

    span_min = min(spans)

    print('- Checking of {} took {:1.3f} seconds (using "{}")'.format(path, span_min, args[0]))

    return span


def long_types_of_lang(lang):
    if lang in ['c', 'c++', 'java']:
        return ['long']
    elif lang in ['d']:
        return ['long']
    elif lang in ['rust', 'zig', 'v']:
        return ['i64']
    elif lang == 'go':
        return ['int64']
    elif lang == 'julia':
        return ['Int64']
    else:
        return None


def file_ext_of_lang(lang):
    if lang == 'rust':
        return 'rs'
    elif lang == 'julia':
        return 'jl'
    else:
        return lang


def generate_test_program_1(function_count, language, root_path='generated',
                            templated_function=False):
    program_name = 'sample1'

    lang = language.lower()
    types = long_types_of_lang(lang)
    ext = file_ext_of_lang(lang)
    dir_path = os.path.join(root_path, lang)
    os.makedirs(dir_path, exist_ok=True)
    path = os.path.join(dir_path, program_name + '.' + ext)

    start = timer()
    with open(path, 'w') as f:

        # package definition
        if lang == "go":
            f.write('package ' + program_name + ';\n\n')
        if lang == "v":
            f.write('import os\n\n')

        # special modules
        if lang == "rust":
            f.write('use std::process::exit;\n')

        # special class wrapping
        if lang == "java":
            f.write('class HelloWorld {\n')

        for typ in types:
            for n in range(0, function_count):
                if lang in ["c"]:
                    f.write(Tm('${T} add_${T}_${N}(${T} x) { return x + ${N}; }\n').substitute(T=typ, N=str(n)))
                elif lang in ["java"]:
                    f.write(Tm('    static ${T} add_${T}_${N}(${T} x) { return x + ${N}; }\n').substitute(T=typ, N=str(n)))
                elif lang in ["c++"]:
                    f.write(Tm('${X}${T} add_${T}_${N}(${T} x) { return x + ${N}; }\n')
                            .substitute(T=typ,
                                        N=str(n),
                                        X='template<typename T=int> ' if templated_function else ''))
                    # template<typename T1, typename T2 = int> class A;
                if lang in ["d"]:
                    f.write(Tm('${T} add_${T}_${N}${X}(${T} x) pure { return x + ${N}; }\n')
                            .substitute(T=typ,
                                        N=str(n),
                                        X='(alias T=void)' if templated_function else ''))
                elif lang == "rust":
                    f.write(Tm('fn add_${T}_${N}(x: ${T}) -> ${T} { x + ${N} }\n').substitute(T=typ, N=str(n)))
                elif lang == "zig":
                    f.write(Tm('fn add_${T}_${N}(x: ${T}) ${T} { return x + ${N}; }\n').substitute(T=typ, N=str(n)))
                elif lang == "go":
                    f.write(Tm('func add_${T}_${N}(x ${T}) ${T} { return x + ${N} }\n').substitute(T=typ, N=str(n)))
                elif lang == "v":
                    f.write(Tm('fn add_${T}_${N}(x ${T}) ${T} { return x + ${N} }\n').substitute(T=typ, N=str(n)))
                elif lang == "julia":
                    f.write(Tm('function add_${T}_${N}(x::${T})::${T}\n    return x + ${N}\nend;\n').substitute(T=typ, N=str(n)))
            f.write('\n')

        # MAIN HEADER
        if lang in ["c", "c++"]:
            f.write('int main(__attribute__((unused)) int argc, __attribute__((unused)) char* argv[]) {\n')
        elif lang == "java":
            f.write('    public static void main(String args[]) {\n')
        elif lang == "d":
            f.write('int main(string[] args) {\n')
        elif lang == "rust":
            f.write(Tm('fn main() {\n').substitute(T=types[0]))
        elif lang == "zig":
            f.write(Tm('pub fn main() void {\n').substitute(T=types[0]))
        elif lang == "go":
            f.write(Tm('func main() ${T} {\n').substitute(T=types[0]))
        elif lang == "v":
            f.write(Tm('fn main() {\n').substitute(T=types[0]))
        elif lang == "julia":
            f.write(Tm('function main()::${T}\n').substitute(T=types[0]))
        else:
            assert False

        # CALCULATE
        for typ in types:
            if lang in ["c", "c++", "d"]:
                f.write(Tm('    ${T} ${T}_sum = 0;\n').substitute(T=typ))
            elif lang in ["java"]:
                f.write(Tm('        ${T} ${T}_sum = 0;\n').substitute(T=typ))
            elif lang == "rust":
                f.write(Tm('    let mut ${T}_sum : ${T} = 0;\n').substitute(T=typ))
            elif lang == "zig":
                f.write(Tm('    var ${T}_sum: ${T} = 0;\n').substitute(T=typ))
            elif lang == "go":
                f.write(Tm('    var ${T}_sum ${T} = 0;\n').substitute(T=typ))
            elif lang == "v":
                f.write(Tm('    mut ${T}_sum := ${T}(0)\n').substitute(T=typ))
            elif lang == "julia":
                f.write(Tm('    ${T}_sum::${T} = 0;\n').substitute(T=typ))
            else:
                assert False

            for n in range(0, function_count):
                if lang in ["java"]:
                    f.write('    ')
                f.write(Tm('    ${T}_sum += add_${T}_${N}(${N})').substitute(T=typ, N=str(n)))
                if lang not in ["v"]:
                    f.write(';')
                f.write('\n')

        if lang == "rust":
            f.write(Tm('    exit((${T}_sum % 4294967296) as i32);\n}\n').substitute(T=types[0]))
        elif lang == "v":
            f.write(Tm('    exit(int(${T}_sum))\n}\n').substitute(T=types[0]))
        elif lang == "java":
            f.write(Tm('        System.exit(${T}_sum == 42 ? 1 : 0);\n    }\n').substitute(T=types[0]))
        elif lang == "zig":
            f.write(Tm('\n}\n').substitute(T=types[0]))
        elif lang == "julia":
            f.write(Tm('''    return ${T}_sum;
end

main()
''').substitute(T=types[0]))
        elif lang == "d":
            f.write(Tm('''    return cast(int)${T}_sum;
}
''').substitute(T=types[0]))
        else:
            f.write(Tm('''    return ${T}_sum;
}
''').substitute(T=types[0]))

        if lang == "java":
            f.write('}\n')            # one extra closing brace for class

    end = timer()
    span = (end - start)  # time span
    print("- Generating {} took {:1.3f} seconds ({})".format(path, span, language))

    # print("Generated {} source file: {}".format(language.upper(), path))

    return path  # "-betterC"


def generate_test_program_2(function_count, language, root_path='generated'):
    program_name = "sample2"

    lang = language.lower()
    types = long_types_of_lang(lang)
    ext = file_ext_of_lang(lang)
    dir_path = os.path.join(root_path, lang)
    os.makedirs(dir_path, exist_ok=True)
    path = os.path.join(dir_path, program_name + "." + ext)

    start = timer()
    with open(path, 'w') as f:

        # package definition
        if lang == "go":
            f.write('''package ''' + program_name + ''';

''')

        # standard io module
        if lang in ["c"]:
            f.write('''#include <stdio.h>
''')
        if lang in ["c++"]:
            f.write('''#include <iostream>
''')
        if lang == "d":
            f.write('''import std.stdio;
''')
        if lang == "rust":
            f.write('''use std::io;
''')
        if lang == "go":
            f.write('''import "fmt";

''')
        if lang == "v":
            f.write('''import os
''')

        # special modules
        if lang == "rust":
            f.write('''use std::process::exit;
''')

        for typ in types:
            for n in range(0, function_count):
                if lang in ["c", "c++"]:
                    f.write(Tm('''${T} add_${T}_${N}(${T} x) { return x + ${N}; }
''').substitute(T=typ, N=str(n)))
                if lang in ["d"]:
                    f.write(Tm('''${T} add_${T}_${N}(${T} x) pure { return x + ${N}; }
''').substitute(T=typ, N=str(n)))
                elif lang == "rust":
                    f.write(Tm('''fn add_${T}_${N}(x: ${T}) -> ${T} { x + ${N} }
''').substitute(T=typ, N=str(n)))
                elif lang == "zig":
                    f.write(Tm('''fn add_${T}_${N}(x: ${T}) ${T} { return x + ${N}; }
''').substitute(T=typ, N=str(n)))
                elif lang == "go":
                    f.write(Tm('''func add_${T}_${N}(x ${T}) ${T} { return x + ${N} }
''').substitute(T=typ, N=str(n)))
                elif lang == "v":
                    f.write(Tm('''fn add_${T}_${N}(x ${T}) ${T} { return x + ${N} }
''').substitute(T=typ, N=str(n)))
                elif lang == "julia":
                    f.write(Tm('''function add_${T}_${N}(x::${T})::${T}
    return x + ${N}
end;
''').substitute(T=typ, N=str(n)))
                    f.write('\n')

        # MAIN HEADER
        if lang in ["c", "c++"]:
            f.write('''int main(__attribute__((unused)) int argc, __attribute__((unused)) char* argv[])
{
''')
        elif lang == "d":
            f.write('''int main(string[] args)
{
''')
        elif lang == "rust":
            f.write(Tm('''fn main() {
''').substitute(T=types[0]))
        elif lang == "zig":
            f.write(Tm('''pub fn main() void {
''').substitute(T=types[0]))
        elif lang == "go":
            f.write(Tm('''func main() ${T} {
''').substitute(T=types[0]))
        elif lang == "v":
            f.write(Tm('''fn main() ${T} {
''').substitute(T=types[0]))
        elif lang == "julia":
            f.write(Tm('''function main()::${T}
''').substitute(T=types[0]))
        else:
            assert False

        # CALCULATE
        for typ in types:
            if lang in ["c", "c++", "d"]:
                f.write(Tm('''    ${T} ${T}_sum = 0;
''').substitute(T=typ))
            elif lang == "rust":
                f.write(Tm('''    let mut ${T}_sum : ${T} = 0;
''').substitute(T=typ))
            elif lang == "zig":
                f.write(Tm('''    var ${T}_sum: ${T} = 0;
''').substitute(T=typ))
            elif lang == "go":
                f.write(Tm('''    var ${T}_sum ${T} = 0;
''').substitute(T=typ))
            elif lang == "v":
                f.write(Tm('''    var ${T}_sum ${T} = 0;
''').substitute(T=typ))
            elif lang == "julia":
                f.write(Tm('''    ${T}_sum::${T} = 0;
''').substitute(T=typ))
            else:
                assert False

            for n in range(0, function_count):
                f.write(Tm('''    ${T}_sum += add_${T}_${N}(${N});
''').substitute(T=typ, N=str(n)))

        if lang == "rust":
            f.write(Tm('''    exit(${T}_sum);
}
''').substitute(T=types[0]))
        elif lang == "zig":
            f.write(Tm('''
}
''').substitute(T=types[0]))
        elif lang == "julia":
            f.write(Tm('''    return ${T}_sum;
end

main()
''').substitute(T=types[0]))
        elif lang == "d":
            f.write(Tm('''    return cast(int)${T}_sum;
}
''').substitute(T=types[0]))
        else:
            f.write(Tm('''    return ${T}_sum;
}
''').substitute(T=types[0]))

    end = timer()
    span = (end - start)  # time span
    print("- Generating {} took {:1.3f} seconds ({})".format(path, span, language))

    # print("Generated {} source file: {}".format(language.upper(), path))

    return path  # "-betterC"


def print_speedup(spans, from_lang, to_lang):
    try:
        print("- Speedup of {} over {}: {:.2f}".format(from_lang,
                                                       to_lang,
                                                       spans[to_lang] / spans[from_lang]))
    except KeyError:
        pass


if __name__ == '__main__':
    main()
